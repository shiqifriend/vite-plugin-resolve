import type { LibMeta, LibEsmResult } from './type';
import libEsm from 'lib-esm';

interface VuePreset {
  v2: string;
  v3: string;
}

const vue_v2: LibMeta = {
  name: 'Vue',
  members: [
    'util',
    'set',
    'delete',
    'nextTick',
    'observable',
    'options',
    'use',
    'mixin',
    'cid',
    'extend',
    'component',
    'directive',
    'filter',
    'version',
    'compile',
  ],
};
const vue_v3: LibMeta = {
  name: 'Vue',
  members: [
    'BaseTransition',
    'Comment',
    'EffectScope',
    'Fragment',
    'KeepAlive',
    'ReactiveEffect',
    'Static',
    'Suspense',
    'Teleport',
    'Text',
    'Transition',
    'TransitionGroup',
    'VueElement',
    'callWithAsyncErrorHandling',
    'callWithErrorHandling',
    'camelize',
    'capitalize',
    'cloneVNode',
    'compatUtils',
    'compile',
    'computed',
    'createApp',
    'createBlock',
    'createCommentVNode',
    'createElementBlock',
    'createElementVNode',
    'createHydrationRenderer',
    'createPropsRestProxy',
    'createRenderer',
    'createSSRApp',
    'createSlots',
    'createStaticVNode',
    'createTextVNode',
    'createVNode',
    'customRef',
    'defineAsyncComponent',
    'defineComponent',
    'defineCustomElement',
    'defineEmits',
    'defineExpose',
    'defineProps',
    'defineSSRCustomElement',
    'effect',
    'effectScope',
    'getCurrentInstance',
    'getCurrentScope',
    'getTransitionRawChildren',
    'guardReactiveProps',
    'h',
    'handleError',
    'hydrate',
    'initCustomFormatter',
    'initDirectivesForSSR',
    'inject',
    'isMemoSame',
    'isProxy',
    'isReactive',
    'isReadonly',
    'isRef',
    'isRuntimeOnly',
    'isShallow',
    'isVNode',
    'markRaw',
    'mergeDefaults',
    'mergeProps',
    'nextTick',
    'normalizeClass',
    'normalizeProps',
    'normalizeStyle',
    'onActivated',
    'onBeforeMount',
    'onBeforeUnmount',
    'onBeforeUpdate',
    'onDeactivated',
    'onErrorCaptured',
    'onMounted',
    'onRenderTracked',
    'onRenderTriggered',
    'onScopeDispose',
    'onServerPrefetch',
    'onUnmounted',
    'onUpdated',
    'openBlock',
    'popScopeId',
    'provide',
    'proxyRefs',
    'pushScopeId',
    'queuePostFlushCb',
    'reactive',
    'readonly',
    'ref',
    'registerRuntimeCompiler',
    'render',
    'renderList',
    'renderSlot',
    'resolveComponent',
    'resolveDirective',
    'resolveDynamicComponent',
    'resolveFilter',
    'resolveTransitionHooks',
    'setBlockTracking',
    'setDevtoolsHook',
    'setTransitionHooks',
    'shallowReactive',
    'shallowReadonly',
    'shallowRef',
    'ssrContextKey',
    'ssrUtils',
    'stop',
    'toDisplayString',
    'toHandlerKey',
    'toHandlers',
    'toRaw',
    'toRef',
    'toRefs',
    'transformVNodeArgs',
    'triggerRef',
    'unref',
    'useAttrs',
    'useCssModule',
    'useCssVars',
    'useSSRContext',
    'useSlots',
    'useTransitionState',
    'vModelCheckbox',
    'vModelDynamic',
    'vModelRadio',
    'vModelSelect',
    'vModelText',
    'vShow',
    'version',
    'warn',
    'watch',
    'watchEffect',
    'watchPostEffect',
    'watchSyncEffect',
    'withAsyncContext',
    'withCtx',
    'withDefaults',
    'withDirectives',
    'withKeys',
    'withMemo',
    'withModifiers',
    'withScopeId',
  ],
};

const v2_result: LibEsmResult = libEsm({
  window: vue_v2.name,
  exports: vue_v2.members,
});
const v3_result: LibEsmResult = libEsm({
  window: vue_v3.name,
  exports: vue_v3.members,
});

export const vue: VuePreset = {
  v2: `${v2_result.window}\n${v2_result.exports}`,
  v3: `${v3_result.window}\n${v3_result.exports}`,
};
